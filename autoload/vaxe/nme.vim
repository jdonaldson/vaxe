function! vaxe#nme#Targets(...)
    return s:nmml_targets
endfunction

function! vaxe#nme#Update(...)
    if (a:0 && a:1 != '')
        let target = split(a:1)[0]
    else
        let target = g:vaxe_nme_target
    endif
    let command = "nme update ".target
    call s:Log(command)
    call s:Sys(command)
endfunction

function! vaxe#nme#ProjectNmml(...)
    if exists('g:vaxe_nmml')
        unlet g:vaxe_nmml
    endif
    let g:vaxe_working_directory = getcwd()

    if a:0 > 0 && a:1 != ''
        let g:vaxe_nmml = expand(a:1,':p')
    else
        let nmmls = split(glob("**/*.nmml"),'\n')

        if len(nmmls) == 0
            echoerr "No nmml files found in current working directory"
            return
        else
            let base_nmml = vaxe#util#InputList("Select Nmml", nmmls)
        endif

        if base_nmml !~ "^\([a-zA-Z]:\)\=[/\\]"
            let base_nmml = getcwd() . '/' . base_nmml
        endif

        let g:vaxe_nmml = base_nmml
    endif
    if !filereadable(g:vaxe_nmml)
        echoerr "Project nmml file not valid, please create one."
        return
    endif
    call vaxe#SetCompiler()
    return g:vaxe_nmml
endfunction

function! vaxe#nme#Clean(...)
    if (a:0 && a:1 != '')
        let target = split(a:1)[0]
    else
        let target = g:vaxe_nme_target
    endif
    let command = "nme clean ".target
    call s:Log(command)
    call s:Sys(command)
endfunction

"A simple system function that first changes directory to the current vaxe
"working directory
function! s:Sys(cmd)
    call system("cd ".g:vaxe_working_directory." && ".a:cmd)
endfunction

function! vaxe#nme#BuildNmmlHxml()
    let base_hxml = b:vaxe_nmml.".hxml"

    if !strlen(g:vaxe_nme_target)
        call vaxe#nme#Target()
    endif

    let g:vaxe_working_directory = fnamemodify(b:vaxe_nmml, ":p:h")
    let cdcmd = 'cd "'.g:vaxe_working_directory.'" && '

    "create the nmml.hxml if not present
    if !filereadable(base_hxml)
        " pipe nme display to an hxml for completions
        let escape_base = fnameescape(base_hxml)
        call s:Sys(" echo '# THIS FILE IS AUTOGENERATED BY VAXE, ANY EDITS ARE DISCARDED' " . " > " . escape_base)
        call s:Sys(" nme display " . g:vaxe_nme_target
                    \. " >> " . escape_base )
    endif

    " create the boilerplate code if missing
    let simple_target = split(g:vaxe_nme_target)[0]
    if (!isdirectory(g:vaxe_working_directory."/bin/".simple_target))
        " build the assets dependencies
        call system(cdcmd . " nme update " . g:vaxe_nme_target)
    else
    endif

    let g:vaxe_nmml = b:vaxe_nmml
    let b:vaxe_hxml = base_hxml
    " let g:vaxe_hxml = b:vaxe_hxml " don't set a global projet var by default
endfunction

"Sets the target.  If target is missing it asks the user. Also updates the
"makeprg compiler command
function! vaxe#nme#Target(...)
    let g:vaxe_nme_target = ''
    if a:0 > 0 && a:1 != ''
        let g:vaxe_nme_target = a:1
    else
        let g:vaxe_nme_target = vaxe#util#InputList("Select Nmml Target", s:nmml_targets)
        let g:vaxe_nme_target = split(g:vaxe_nme_target, ":")[0]
    endif
    call vaxe#nme#BuildNmmlHxml()
    call vaxe#SetCompiler()
endfunction


" A list of all the nme targets
let s:nmml_targets = [ "android : Create Google Android applications"
            \, "android -arm7 : Compile for arm-7a and arm5"
            \, "android -arm7-only : Compile for arm-7a for testing"
            \, "blackberry : Create BlackBerry applications"
            \, "blackberry -simulator : Build/test for the device simulator"
            \, "flash : Create SWF applications for Adobe Flash Player"
            \, "html5 : Create HTML5 canvas applications"
            \, "html5 -minify : Minify output using the Google Closure compiler"
            \, "html5 -minify -yui : Minify output using the YUI compressor"
            \, "ios : Create Apple iOS applications"
            \, "ios -simulator : Build/test for the device simulator"
            \, "ios -simulator -ipad : Build/test for the iPad Simulator"
            \, "linux : Create Linux applications"
            \, "linux -64 : Compile for 64-bit instead of 32-bit"
            \, "linux -neko : Build with Neko instead of C++"
            \, "linux -neko -64 : Build with Neko 64-bit instead of C++"
            \, "mac : Create Apple Mac OS X applications"
            \, "mac -neko : Build with Neko instead of C++"
            \, "mac -neko -64 : Build with Neko 64-bit instead of C++"
            \, "webos : Create HP webOS applications"
            \, "windows : Create Microsoft Windows applications"
            \, "windows -neko : Build with Neko instead of C++"
            \, "windows -neko -64 : Build with Neko 64-bit instead of C++" ]

  " -D : Specify a define to use when processing other commands
  " -debug : Use debug configuration instead of release
  " -verbose : Print additional information (when available)
  " -clean : Add a "clean" action before running the current command
  " (display) -hxml : Print HXML information for the project
  " (display) -nmml : Print NMML information for the project
